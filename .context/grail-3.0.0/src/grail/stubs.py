"""Type stub generator for Monty's type checker."""

import logging
import re

from grail._types import ExternalSpec, InputSpec

logger = logging.getLogger(__name__)

_TYPING_NAMES: set[str] = {
    "Any",
    "Optional",
    "Union",
    "List",
    "Dict",
    "Set",
    "Tuple",
    "Callable",
    "Awaitable",
    "Iterator",
    "Iterable",
    "Sequence",
    "MutableSequence",
    "Mapping",
    "MutableMapping",
    "Protocol",
    "TypeVar",
    "Literal",
    "Annotated",
    "Final",
    "TypedDict",
    "NotRequired",
    "Required",
    "ClassVar",
    "Generic",
    "ParamSpec",
    "Concatenate",
    "TypeAlias",
    "TypeGuard",
    "Never",
    "Self",
}


def _collect_typing_imports(type_str: str) -> set[str]:
    """Return typing names referenced inside the annotation."""
    return {name for name in _TYPING_NAMES if re.search(rf"\b{name}\b", type_str)}


def generate_stubs(
    externals: dict[str, ExternalSpec],
    inputs: dict[str, InputSpec],
) -> str:
    """
    Generate .pyi stub file content from declarations.

    Args:
        externals: External function specifications.
        inputs: Input variable specifications.

    Returns:
        .pyi file content as string.
    """
    logger.debug("Generating stubs: %d externals, %d inputs", len(externals), len(inputs))

    lines = ["# Auto-generated by grail â€” do not edit", ""]

    typing_imports: set[str] = set()

    for external in externals.values():
        typing_imports.update(_collect_typing_imports(external.return_type))
        for param in external.parameters:
            typing_imports.update(_collect_typing_imports(param.type_annotation))

    for input_spec in inputs.values():
        typing_imports.update(_collect_typing_imports(input_spec.type_annotation))

    if typing_imports:
        imports = ", ".join(sorted(typing_imports))
        lines.append(f"from typing import {imports}")
        lines.append("")

    if inputs:
        for input_spec in inputs.values():
            lines.append(f"{input_spec.name}: {input_spec.type_annotation}")
        lines.append("")

    for external in externals.values():
        params = []
        for param in external.parameters:
            if param.default is not None:
                if isinstance(param.default, str):
                    params.append(f"{param.name}: {param.type_annotation} = {param.default}")
                else:
                    params.append(f"{param.name}: {param.type_annotation} = {repr(param.default)}")
            else:
                params.append(f"{param.name}: {param.type_annotation}")

        params_str = ", ".join(params)

        if external.is_async:
            lines.append(f"async def {external.name}({params_str}) -> {external.return_type}:")
        else:
            lines.append(f"def {external.name}({params_str}) -> {external.return_type}:")

        if external.docstring:
            escaped = external.docstring.replace("\\", "\\\\").replace('"""', '\\"\\"\\"')
            lines.append(f'    """{escaped}"""')

        lines.append("    ...")
        lines.append("")

    return "\n".join(lines)
