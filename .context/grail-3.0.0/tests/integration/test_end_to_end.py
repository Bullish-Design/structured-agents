"""End-to-end integration tests."""

import json
import pytest
from pathlib import Path
import tempfile

pytest.importorskip("pydantic_monty")

import grail


@pytest.mark.integration
async def test_full_workflow():
    """Test complete workflow: load -> check -> run."""
    # Create a temporary .pym file
    with tempfile.NamedTemporaryFile(mode="w", suffix=".pym", delete=False) as f:
        f.write("""
from grail import external, Input
from typing import Any

budget: float = Input("budget")
department: str = Input("department", default="Engineering")

@external
async def get_team_size(dept: str) -> int:
    '''Get team size for department.'''
    ...

@external
async def calculate_budget(size: int, per_person: float) -> float:
    '''Calculate total budget.'''
    ...

size = await get_team_size(department)
total = await calculate_budget(size, budget / 10)

{
    "department": department,
    "team_size": size,
    "total_budget": total,
    "over_budget": total > budget
}
""")
        pym_path = Path(f.name)

    try:
        # Load
        script = grail.load(pym_path, grail_dir=None)

        # Check
        check_result = script.check()
        assert check_result.valid is True

        # Run
        async def get_team_size_impl(dept: str) -> int:
            return 5

        async def calculate_budget_impl(size: int, per_person: float) -> float:
            return size * per_person

        result = await script.run(
            inputs={"budget": 1000.0, "department": "Engineering"},
            externals={
                "get_team_size": get_team_size_impl,
                "calculate_budget": calculate_budget_impl,
            },
        )

        assert result["department"] == "Engineering"
        assert result["team_size"] == 5
        assert result["total_budget"] == 500.0
        assert result["over_budget"] is False

    finally:
        pym_path.unlink()


@pytest.mark.integration
async def test_load_check_run_workflow(tmp_path):
    """Full workflow: load a .pym file, check it, and run it."""
    pym_path = tmp_path / "workflow.pym"
    pym_path.write_text(
        """
from grail import external, Input

x: int = Input("x")

@external
async def add_one(value: int) -> int:
    ...

result = await add_one(x)
result
"""
    )

    script = grail.load(pym_path, grail_dir=None)

    check_result = script.check()
    assert check_result.valid is True

    async def add_one_impl(value: int) -> int:
        return value + 3

    result = await script.run(inputs={"x": 4}, externals={"add_one": add_one_impl})
    assert result == 7


@pytest.mark.integration
def test_load_produces_artifacts(tmp_path):
    """Loading a script should produce .grail/ artifacts."""
    pym_path = tmp_path / "artifacts.pym"
    pym_path.write_text(
        """
from grail import external, Input

x: int = Input("x")

@external
async def add_one(value: int) -> int:
    ...

await add_one(x)
"""
    )

    grail_dir = tmp_path / ".grail"
    grail.load(pym_path, grail_dir=grail_dir)

    artifacts_dir = grail_dir / "artifacts"
    stubs_path = artifacts_dir / "stubs.pyi"
    monty_code_path = artifacts_dir / "monty_code.py"
    check_path = artifacts_dir / "check.json"

    assert stubs_path.exists()
    assert monty_code_path.exists()
    assert check_path.exists()

    stubs_content = stubs_path.read_text()
    assert "async def add_one" in stubs_content
    assert "x: int" in stubs_content

    monty_code = monty_code_path.read_text()
    assert "Auto-generated by grail" in monty_code
    assert "await add_one" in monty_code

    check_data = json.loads(check_path.read_text())
    assert check_data["valid"] is True
    assert "errors" in check_data


@pytest.mark.integration
def test_inline_run():
    """Test grail.run() for inline code."""
    import asyncio

    result = asyncio.run(grail.run("x + y", inputs={"x": 1, "y": 2}))
    assert result == 3


@pytest.mark.integration
async def test_with_resource_limits():
    """Test execution with resource limits."""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".pym", delete=False) as f:
        f.write("""
from grail import Input

x: int = Input("x")

x * 2
""")
        pym_path = Path(f.name)

    try:
        script = grail.load(pym_path, limits=grail.Limits.strict(), grail_dir=None)

        result = await script.run(inputs={"x": 5})
        assert result == 10

    finally:
        pym_path.unlink()


@pytest.mark.integration
def test_error_handling():
    """Test that errors are properly caught and mapped."""
    import asyncio

    with tempfile.NamedTemporaryFile(mode="w", suffix=".pym", delete=False) as f:
        f.write("""
from grail import Input

x: int = Input("x")

y = undefined_variable
""")
        pym_path = Path(f.name)

    try:
        script = grail.load(pym_path, grail_dir=None)

        with pytest.raises(grail.ExecutionError):
            asyncio.run(script.run(inputs={"x": 5}))

    finally:
        pym_path.unlink()


@pytest.mark.asyncio
async def test_print_callback_captures_output():
    """print_callback receives output from print() inside Monty."""
    output = []

    def capture(stream, text):
        output.append(text)

    result = await grail.run(
        'print("hello from monty")\n42',
        print_callback=capture,
    )

    assert result == 42
    stdout = "".join(output)
    assert "hello from monty" in stdout


@pytest.mark.asyncio
async def test_on_event_receives_lifecycle_events():
    """on_event callback receives structured lifecycle events."""
    # This test requires a .pym file â€” use the fixture
    script = grail.load("tests/fixtures/simple.pym", grail_dir=None)

    events = []

    async def mock_external(x):
        return x * 2

    result = await script.run(
        inputs={"x": 5},
        externals={"double": mock_external},
        on_event=lambda e: events.append(e),
    )

    event_types = [e.type for e in events]
    assert "run_start" in event_types
    assert "run_complete" in event_types
