from grail import Input, external
from typing import Any

node_text_input: str | None = Input("node_text", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


async def _load_node_text() -> str:
    if node_text_input:
        return node_text_input
    stored = await _read_optional(path=".remora/node_text")
    if stored:
        return stored
    target_file = await _resolve_target_file()
    if target_file and await file_exists(path=target_file):
        return await read_file(path=target_file)
    return ""


def _find_signature_line(source: str) -> str | None:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("async def ") or stripped.startswith("def "):
            return stripped
    return None


def _parse_parameters(raw: str) -> list[dict[str, str]]:
    params: list[dict[str, str]] = []
    pieces = [piece.strip() for piece in raw.split(",") if piece.strip()]
    for piece in pieces:
        name_type = piece.split("=", 1)[0].strip()
        if ":" not in name_type:
            continue
        name, annotation = [part.strip() for part in name_type.split(":", 1)]
        if annotation:
            params.append({"name": name, "annotation": annotation})
    return params


def _parse_return_type(line: str) -> str | None:
    if ")" not in line or "->" not in line:
        return None
    after = line.split(")", 1)[1]
    if "->" not in after:
        return None
    return after.split("->", 1)[1].split(":", 1)[0].strip() or None


try:
    source = await _load_node_text()
    signature_line = _find_signature_line(source)
    if not signature_line:
        error_message = "No function definition found in node text."
        result = {
            "result": None,
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        params_part = signature_line.split("(", 1)[1].split(")", 1)[0]
        parameters = _parse_parameters(params_part)
        return_annotation = _parse_return_type(signature_line)
        has_annotations = bool(parameters or return_annotation)
        raw_result = {
            "parameters": parameters,
            "return_annotation": return_annotation,
            "has_annotations": has_annotations,
        }
        if has_annotations:
            summary = f"Found type hints for {len(parameters)} parameter(s)"
            outcome = "success"
        else:
            summary = "No type hints found"
            outcome = "partial"
        result = {
            "result": raw_result,
            "summary": summary,
            "knowledge_delta": {
                "type_hints_present": has_annotations,
                "type_hints_count": len(parameters),
                "type_hints_return": return_annotation,
            },
            "outcome": outcome,
        }
except Exception as exc:
    result = {
        "result": None,
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
