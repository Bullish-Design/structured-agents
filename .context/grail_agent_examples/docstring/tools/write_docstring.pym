from grail import Input, external

docstring: str = Input("docstring")
style: str = Input("style")
node_text_input: str | None = Input("node_text", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def write_file(path: str, content: str) -> bool:
    """Write text content to a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


async def _load_node_text() -> str:
    if node_text_input:
        return node_text_input
    stored = await _read_optional(path=".remora/node_text")
    if stored:
        return stored
    return ""


def _find_function_name(source: str) -> str | None:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("def "):
            return stripped[len("def ") :].split("(", 1)[0].strip()
        if stripped.startswith("async def "):
            return stripped[len("async def ") :].split("(", 1)[0].strip()
    return None


def _format_docstring(text: str, indent: str) -> list[str]:
    lines = text.splitlines()
    if not lines:
        return [f"{indent}\"\"\"\"\"\""]
    if len(lines) == 1:
        return [f"{indent}\"\"\"{lines[0]}\"\"\""]
    formatted = [f"{indent}\"\"\""]
    formatted.extend(f"{indent}{line}" for line in lines)
    formatted.append(f"{indent}\"\"\"")
    return formatted


def _find_function_line(lines: list[str], name: str) -> tuple[int, int] | None:
    for index, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith(f"def {name}") or stripped.startswith(f"async def {name}"):
            return index, len(line) - len(line.lstrip())
    return None


def _find_docstring_block(lines: list[str], start_index: int, base_indent: int) -> tuple[int, int] | None:
    for index in range(start_index + 1, len(lines)):
        line = lines[index]
        stripped = line.strip()
        if not stripped:
            continue
        indent = len(line) - len(line.lstrip())
        if indent <= base_indent:
            return None
        if stripped.startswith('"""') or stripped.startswith("'''"):
            quote = stripped[:3]
            if stripped.endswith(quote) and len(stripped) > 3:
                return index, index
            for end_index in range(index + 1, len(lines)):
                if quote in lines[end_index]:
                    return index, end_index
            return index, index
        return None
    return None


try:
    _ = style
    if not docstring:
        raise ValueError("Docstring text is required.")

    target_file = await _resolve_target_file()
    if not target_file:
        raise ValueError("Target file not found for docstring insertion.")

    content = await read_file(path=target_file)
    trailing_newline = content.endswith("\n")
    lines = content.splitlines()

    node_text = await _load_node_text()
    function_name = _find_function_name(node_text)
    if not function_name:
        raise ValueError("Function definition not found in node text.")

    location = _find_function_line(lines, function_name)
    if not location:
        raise ValueError("Function definition not found in target file.")

    def_line_index, base_indent = location
    indent = " " * (base_indent + 4)

    docstring_lines = _format_docstring(docstring, indent)
    block = _find_docstring_block(lines, def_line_index, base_indent)

    replaced_existing = False
    if block:
        start, end = block
        lines = lines[:start] + docstring_lines + lines[end + 1 :]
        replaced_existing = True
    else:
        insert_at = def_line_index + 1
        lines = lines[:insert_at] + docstring_lines + lines[insert_at:]

    updated_content = "\n".join(lines)
    if trailing_newline:
        updated_content += "\n"

    await write_file(path=target_file, content=updated_content)
    raw_result = {
        "success": True,
        "replaced_existing": replaced_existing,
        "target_file": target_file,
    }
    summary = "Replaced existing docstring" if replaced_existing else "Inserted new docstring"
    result = {
        "result": raw_result,
        "summary": summary,
        "knowledge_delta": {
            "docstring_updated": True,
            "docstring_replaced": replaced_existing,
            "docstring_target_file": target_file,
        },
        "outcome": "success",
    }
except Exception as exc:
    result = {
        "result": {"success": False, "error": str(exc)},
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
