from grail import Input, external

node_text_input: str | None = Input("node_text", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


async def _load_node_text() -> str:
    if node_text_input:
        return node_text_input
    stored = await _read_optional(path=".remora/node_text")
    if stored:
        return stored
    target_file = await _resolve_target_file()
    if target_file and await file_exists(path=target_file):
        return await read_file(path=target_file)
    return ""


def _find_definition(lines: list[str]) -> tuple[int, int] | None:
    for index, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith("async def ") or stripped.startswith("def ") or stripped.startswith("class "):
            indent = len(line) - len(line.lstrip())
            return index, indent
    return None


def _extract_docstring(lines: list[str], start_index: int, base_indent: int) -> str | None:
    for index in range(start_index + 1, len(lines)):
        line = lines[index]
        stripped = line.strip()
        if not stripped:
            continue
        indent = len(line) - len(line.lstrip())
        if indent <= base_indent:
            return None
        if stripped.startswith('"""') or stripped.startswith("'''"):
            quote = stripped[:3]
            remainder = stripped[3:]
            if remainder.endswith(quote):
                return remainder[: -3].strip()
            content_lines: list[str] = []
            if remainder:
                content_lines.append(remainder)
            for inner_index in range(index + 1, len(lines)):
                inner_line = lines[inner_index]
                if quote in inner_line:
                    before = inner_line.split(quote, 1)[0]
                    content_lines.append(before)
                    return "\n".join(content_lines).strip()
                content_lines.append(inner_line.strip())
            return "\n".join(content_lines).strip()
        return None
    return None


try:
    source = await _load_node_text()
    lines = source.splitlines()
    definition = _find_definition(lines)
    if not definition:
        error_message = "No docstring-capable node found in node text."
        result = {
            "result": None,
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        index, indent = definition
        docstring = _extract_docstring(lines, index, indent)
        has_docstring = bool(docstring)
        raw_result = {"docstring": docstring, "has_docstring": has_docstring}
        summary = "Found existing docstring" if has_docstring else "No docstring found"
        outcome = "success" if has_docstring else "partial"
        result = {
            "result": raw_result,
            "summary": summary,
            "knowledge_delta": {"docstring_present": has_docstring},
            "outcome": outcome,
        }
except Exception as exc:
    result = {
        "result": None,
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
