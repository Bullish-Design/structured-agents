from grail import Input, external
from typing import Any

node_text_input: str | None = Input("node_text", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


async def _load_node_text() -> str:
    if node_text_input:
        return node_text_input
    stored = await _read_optional(path=".remora/node_text")
    if stored:
        return stored
    target_file = await _resolve_target_file()
    if target_file and await file_exists(path=target_file):
        return await read_file(path=target_file)
    return ""


def _find_signature_line(source: str) -> tuple[str | None, bool]:
    for line in source.splitlines():
        stripped = line.strip()
        if stripped.startswith("async def "):
            return stripped, True
        if stripped.startswith("def "):
            return stripped, False
    return None, False


def _parse_default(value: str) -> Any:
    if value == "None":
        return None
    if value == "True":
        return True
    if value == "False":
        return False
    if value.startswith("\"") and value.endswith("\""):
        return value[1:-1]
    if value.startswith("'") and value.endswith("'"):
        return value[1:-1]
    try:
        return int(value)
    except Exception:
        pass
    try:
        return float(value)
    except Exception:
        return value


def _parse_parameters(raw: str) -> list[dict[str, Any]]:
    params: list[dict[str, Any]] = []
    if not raw.strip():
        return params
    pieces = [piece.strip() for piece in raw.split(",")]
    for piece in pieces:
        if not piece:
            continue
        default_value = None
        name_type = piece
        if "=" in piece:
            name_type, default_raw = piece.split("=", 1)
            default_value = _parse_default(default_raw.strip())
        name_type = name_type.strip()
        annotation = None
        name = name_type
        if ":" in name_type:
            name, annotation = [part.strip() for part in name_type.split(":", 1)]
        params.append({"name": name, "type": annotation, "default": default_value})
    return params


def _parse_signature(line: str, is_async: bool) -> dict[str, Any]:
    signature = line.strip()
    if signature.startswith("async def "):
        signature = signature[len("async ") :]
    signature = signature[len("def ") :]
    name_part, remainder = signature.split("(", 1)
    func_name = name_part.strip()
    params_part = remainder.split(")", 1)[0]
    after_params = remainder.split(")", 1)[1] if ")" in remainder else ""
    return_type = None
    if "->" in after_params:
        return_type = after_params.split("->", 1)[1].split(":", 1)[0].strip()
    return {
        "function_name": func_name,
        "parameters": _parse_parameters(params_part),
        "return_type": return_type if return_type else None,
        "is_async": is_async,
    }


try:
    source = await _load_node_text()
    signature_line, is_async = _find_signature_line(source)
    if not signature_line:
        error_message = "No function definition found in node text."
        result = {
            "result": None,
            "summary": f"Error: {error_message}",
            "knowledge_delta": {},
            "outcome": "error",
            "error": error_message,
        }
    else:
        raw_result = _parse_signature(signature_line, is_async)
        param_count = len(raw_result.get("parameters", []))
        summary = f"Parsed signature for {raw_result.get('function_name', 'function')}"
        result = {
            "result": raw_result,
            "summary": summary,
            "knowledge_delta": {
                "function_name": raw_result.get("function_name"),
                "parameter_count": param_count,
                "return_type": raw_result.get("return_type"),
                "is_async": raw_result.get("is_async"),
            },
            "outcome": "success",
        }
except Exception as exc:
    result = {
        "result": None,
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
