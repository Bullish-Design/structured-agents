from grail import Input, external
from typing import Any

path_input: str | None = Input("path", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


@external
async def run_command(cmd: str, args: list[str]) -> dict[str, Any]:
    """Run a command in the sandbox."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


def _default_test_path(target_file: str) -> str:
    filename = target_file.split("/")[-1]
    module_name = filename.rsplit(".", 1)[0]
    return f"tests/test_{module_name}.py"


def _read_attr(tag: str, key: str) -> int:
    marker = f"{key}=\""
    if marker not in tag:
        return 0
    value = tag.split(marker, 1)[1].split("\"", 1)[0]
    try:
        return int(value)
    except Exception:
        return 0


def _parse_totals(xml: str) -> dict[str, int]:
    tests_total = 0
    failures_total = 0
    errors_total = 0
    skipped_total = 0
    index = 0
    while True:
        start = xml.find("<testsuite", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        tests_total += _read_attr(tag, "tests")
        failures_total += _read_attr(tag, "failures")
        errors_total += _read_attr(tag, "errors")
        skipped_total += _read_attr(tag, "skipped")
        index = end + 1
    return {
        "tests": tests_total,
        "failures": failures_total,
        "errors": errors_total,
        "skipped": skipped_total,
    }


def _read_str_attr(tag: str, key: str) -> str:
    marker = f"{key}=\""
    if marker not in tag:
        return ""
    return tag.split(marker, 1)[1].split("\"", 1)[0]


def _extract_failure_detail(block: str, tag: str) -> str:
    start = block.find(f"<{tag}")
    if start == -1:
        return ""
    end_tag = block.find(">", start)
    if end_tag == -1:
        return ""
    header = block[start:end_tag]
    message = _read_str_attr(header, "message")
    if message:
        return message.strip()
    close = block.find(f"</{tag}>", end_tag)
    if close == -1:
        return ""
    return block[end_tag + 1 : close].strip()


def _parse_failures(xml: str) -> list[dict[str, str]]:
    failures: list[dict[str, str]] = []
    index = 0
    while True:
        start = xml.find("<testcase", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        name = _read_str_attr(tag, "name")
        classname = _read_str_attr(tag, "classname")
        full_name = f"{classname}::{name}" if classname else name
        close = xml.find("</testcase>", end)
        if close == -1:
            index = end + 1
            continue
        body = xml[end:close]
        detail = ""
        if "<failure" in body:
            detail = _extract_failure_detail(body, "failure")
        elif "<error" in body:
            detail = _extract_failure_detail(body, "error")
        if detail:
            failures.append({"test": full_name, "message": detail})
        index = close + len("</testcase>")
    return failures


try:
    target_file = await _resolve_target_file()
    test_path = path_input.strip() if path_input else None
    if not test_path:
        if not target_file:
            raise ValueError("Target file not found for tests.")
        test_path = _default_test_path(target_file)

    if not await file_exists(path=test_path):
        raise ValueError(f"Test file not found: {test_path}")

    report_path = ".remora/pytest_report.xml"
    command_args = [
        "-q",
        "--disable-warnings",
        f"--junitxml={report_path}",
        test_path,
    ]
    completed = await run_command(cmd="pytest", args=command_args)
    stdout = str(completed.get("stdout", ""))
    stderr = str(completed.get("stderr", ""))
    exit_code = int(completed.get("exit_code", 0) or 0)

    if not await file_exists(path=report_path):
        raise RuntimeError(stderr.strip() or stdout.strip() or "Pytest report not generated.")

    xml = await read_file(path=report_path)
    totals = _parse_totals(xml)
    failures = _parse_failures(xml)

    passed = totals["tests"] - totals["failures"] - totals["errors"] - totals["skipped"]
    passed_count = max(passed, 0)
    failed_count = totals["failures"]
    error_count = totals["errors"]
    raw_result = {
        "passed": passed_count,
        "failed": failed_count,
        "errors": error_count,
        "failures": failures,
    }

    if exit_code not in {0, 1}:
        error_count = max(error_count, 1)
        raw_result["errors"] = error_count
        raw_result["failures"].append(
            {
                "test": "pytest",
                "message": stderr.strip() or stdout.strip() or "Pytest failed to run.",
            }
        )

    total_tests = passed_count + failed_count + error_count
    failed_total = failed_count + error_count
    if failed_total == 0:
        summary = f"All {total_tests} tests passed"
        outcome = "success"
    else:
        summary = f"{failed_total} of {total_tests} tests failed"
        outcome = "partial"

    result = {
        "result": raw_result,
        "summary": summary,
        "knowledge_delta": {
            "tests_passed": raw_result["passed"],
            "tests_failed": raw_result["failed"],
            "tests_errors": raw_result["errors"],
        },
        "outcome": outcome,
    }
except Exception as exc:
    result = {
        "result": {
            "passed": 0,
            "failed": 0,
            "errors": 1,
            "failures": [],
        },
        "summary": f"Error: {exc}",
        "knowledge_delta": {},
        "outcome": "error",
        "error": str(exc),
    }

result
