"""Artifacts manager for .grail/ directory."""

import json
from pathlib import Path
from typing import Any

from grail._types import CheckResult, ExternalSpec, InputSpec


class ArtifactsManager:
    """Manages .grail/ directory and generated artifacts."""

    def __init__(self, grail_dir: Path):
        """
        Initialize artifacts manager.

        Args:
            grail_dir: Path to .grail/ directory
        """
        self.grail_dir = grail_dir

    def get_script_dir(self, script_name: str) -> Path:
        """Get directory for a specific script's artifacts."""
        return self.grail_dir / script_name

    def write_script_artifacts(
        self,
        script_name: str,
        stubs: str,
        monty_code: str,
        check_result: CheckResult,
        externals: dict[str, ExternalSpec],
        inputs: dict[str, InputSpec],
    ) -> None:
        """
        Write all artifacts for a script.

        Args:
            script_name: Name of the script
            stubs: Generated type stubs
            monty_code: Generated Monty code
            check_result: Validation results
            externals: External function specs
            inputs: Input specs
        """
        script_dir = self.get_script_dir(script_name)
        script_dir.mkdir(parents=True, exist_ok=True)

        # Write stubs.pyi
        (script_dir / "stubs.pyi").write_text(stubs)

        # Write monty_code.py
        (script_dir / "monty_code.py").write_text(
            "# Auto-generated by grail â€” this is what Monty actually executes\n\n" + monty_code
        )

        # Write check.json
        check_data = {
            "file": check_result.file,
            "valid": check_result.valid,
            "errors": [
                {
                    "line": e.lineno,
                    "column": e.col_offset,
                    "code": e.code,
                    "message": e.message,
                    "suggestion": e.suggestion,
                }
                for e in check_result.errors
            ],
            "warnings": [
                {"line": w.lineno, "column": w.col_offset, "code": w.code, "message": w.message}
                for w in check_result.warnings
            ],
            "info": check_result.info,
        }
        (script_dir / "check.json").write_text(json.dumps(check_data, indent=2))

        # Write externals.json
        externals_data = {
            "externals": [
                {
                    "name": ext.name,
                    "async": ext.is_async,
                    "parameters": [
                        {"name": p.name, "type": p.type_annotation, "default": p.default}
                        for p in ext.parameters
                    ],
                    "return_type": ext.return_type,
                    "docstring": ext.docstring,
                }
                for ext in externals.values()
            ]
        }
        (script_dir / "externals.json").write_text(json.dumps(externals_data, indent=2))

        # Write inputs.json
        inputs_data = {
            "inputs": [
                {
                    "name": inp.name,
                    "type": inp.type_annotation,
                    "required": inp.required,
                    "default": inp.default,
                }
                for inp in inputs.values()
            ]
        }
        (script_dir / "inputs.json").write_text(json.dumps(inputs_data, indent=2))

    def write_run_log(
        self, script_name: str, stdout: str, stderr: str, duration_ms: float, success: bool
    ) -> None:
        """
        Write execution log.

        Args:
            script_name: Name of the script
            stdout: Standard output
            stderr: Standard error
            duration_ms: Execution duration in milliseconds
            success: Whether execution succeeded
        """
        script_dir = self.get_script_dir(script_name)
        script_dir.mkdir(parents=True, exist_ok=True)

        log_lines = []
        log_lines.append(f"[grail] Execution {'succeeded' if success else 'failed'}")
        log_lines.append(f"[grail] Duration: {duration_ms:.2f}ms")
        log_lines.append("")

        if stdout:
            log_lines.append("[stdout]")
            log_lines.append(stdout)
            log_lines.append("")

        if stderr:
            log_lines.append("[stderr]")
            log_lines.append(stderr)

        (script_dir / "run.log").write_text("\n".join(log_lines))

    def clean(self) -> None:
        """Remove the entire .grail/ directory."""
        import shutil

        if self.grail_dir.exists():
            shutil.rmtree(self.grail_dir)
